原文链接：https://github.com/bitshares/bsips/blob/master/bsip-0033.md
译者：bt666

    BSIP:0033
    标题:价格较好的挂单者的订单优先
    作者:Abit More <https://github.com/abitmore>
    状态:安装
    类型:协议
    创建:2018-02-17
    讨论:https://github.com/bitshares/bitshares-core/issues/625
         https://github.com/bitshares/bitshares-core/issues/453
    替换: -
    预算提案:1.14.94

## 摘要 ##

目前，在比特股中，在特定的情况下，吃单者的订单可能会与“不在订单顶部”的挂单者订单相匹配。这种行为对于用户来说是意外而且恼人的。

该BSIP提出了一个原则:总是先将吃单者的订单与具有最佳价格的挂单者的订单(即在订单账本的顶部)相匹配。

## 动机 ##

正如预期的那样，当吃单者的限价单与挂单者的限价单相匹配时，总是先匹配价格较好的挂单者的限价单。

例如，如果交易者A有一个限价单，以0.1 USD / BTS的价格卖出100 BTS，交易者B有一个限价单，以0.09 USD / BTS的价格卖出100 BTS，这意味着B的限价单对于买方来说价格更佳。现在，如果交易员C下订单以每BTS 0.105美元的价格购买10个BTS，B的限价订单将优先，A的限价订单将不会被匹配。

然而，当市场上有(挂单者)追加保证金的订单，且满足了需要匹配的要求(能够追加保证金)时，无论限价单是否提供了更好的价格，它们总是优先于同一侧的(挂单者)的限价单。

例如，如果交易员A的追加保证金订单以不低于0.1美元/BTS的价格卖出100 BTS，那么交易员B有一个限价单，以0.09美元/BTS的价格卖出100 BTS，这意味着B的限价单对于买方来说价格更佳。现在，如果交易员C下订单以每BTS 0.105美元的价格购买10个BTS，A的追加保证金订单将优先，B的限价单颈将不会被匹配。这意味着C在有机会“低买”的时候被迫“高买”，这是出乎意料的。

用户对这种行为感到困惑，正如在[bitshares-core issue #625](https://github.com/bitshares/bitshares-core/issues/625)和其他帖子中讨论的那样。

在[Bitshares-core issue #453](https://github.com/bitshares/bitshares-core/issues/453)中还描述了另一种情况，即有时吃单者的追加保证金的订单可能与一个不在订单账本顶部的挂单者的限价单相匹配。这可以看作是一个bug。

## 基本原理 ##

总是将吃单者的订单(例如购买)与提供最佳价格（又称最低要价）的挂单者的订单相匹配，这是一个更简单的规则，大多数用户很容易理解。

在喂价中有一个参数叫MSSR，代表“最大空头挤压比”。保证金追加订单的挂单价为MSSP，即“最大空头挤压价格”，计算方法为feed_price / MSSR。注意:这里的feed_price是就债务/抵押而言的，也就是“每个抵押的债务”。

也就是说，追加保证金的订单提供的价格是MSSP。限价单提供的价格就是限价。

当以超出最低卖价的价格下一个限价(如购买)单时,订单预计将“走出账本”,按该订单的价格依次匹配另一方的每个订单,直到完全成交新的限价单,或没有更多的与其价格相匹配的卖单。

为了达到预期，

- 首先，我们需要将限购单与价格低于MSSP的限卖单进行匹配，且价格能够与新订单匹配;
- 然后，如果新的限购单没有完全成交，如果MSSP能够与订单的价格匹配，则将其与追加保证金订单匹配;
- 然后，如果新的限购单还没有完全成交，那么将它与其他卖单匹配，直到它完全成交，或者不再有与其价格匹配的卖单

## 详情 ##

### 匹配吃单者的追加保证金订单 ###

在数据库类的apply_order(…)函数中正在处理新的限价单。

目前，在函数中，首先会检查并匹配调用订单。在此之后，将检查并匹配另一方的限价单。

需要将逻辑更改为:

1. 首先，按最优价格最先、MSSP价格最末的价格排序规则对另一方的限价单进行排序;调用match(…)函数一个接一个地检查它们，直到返回值不是2，这意味着新订单完全成交;
1. 如果到达最末(MSSP)，这意味着新订单仍然没完全成交，调用check_call_orders(..)函数或等价的函数;
1. 检查new_order_object是否仍然存在，如果存在，重做第一步，但将市场的最大可能价格设置为最终价格。

### 匹配买家追加保证金订单 ###

对[bitshares-core issue #453](https://github.com/bitshares/bitshares-core/issues/453)，在数据库类的check_call_orders(…)函数中，当变量filled_limit为true时，迭代器limit_itr将向前移动。当限价单完全成交时，filled_limit将设置为true。然而，由于filled_limit从while代码块之外声明，所以在limit_itr向前移动之后，它不会被重置为false。这意味着第一个限价单成交后,filled_limit永远为true的,所以limit_itr总是前进，不管当前限制订单是否已经成交,所以吃单者的追加单可能与不在订单账本顶部的限价单相匹配。

要修复这个问题，需要修改代码以确保limit_itr在解除引用时总是引用订单账本顶部的限制单。

## 讨论 ##

[如果有，再添加]

## 股东总结 ##

[如果有，再添加]

## 版权 ##

本文档放置于公共域名下。

## 查看 ##

- [https://github.com/bitshares/bitshares-core/issues/625](https://github.com/bitshares/bitshares-core/issues/625)
- [https://github.com/bitshares/bitshares-core/issues/453](https://github.com/bitshares/bitshares-core/issues/453)
- [https://bitsharestalk.org/index.php?topic=25926.0](https://github.com/bitshares/bitshares-core/issues/625)
