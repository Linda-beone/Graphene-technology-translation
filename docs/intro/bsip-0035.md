原文链接：https://github.com/bitshares/bsips/blob/master/bsip-0035.md

译者：bt666

    BSIP：0035
    标题：减少订单匹配的四舍五入的问题
    作者：Abit More <https://github.com/abitmore>
    状态：已安装
    类型：协议
    创建时间：2018-02-19
    讨论：https：//github.com/bitshares/bitshares-core/issues/132，
                https://github.com/bitshares/bitshares-core/issues/184，
                https://github.com/bitshares/bitshares-core/issues/342
    被取代：0038（部分）
    工人：1.14.96

## 摘要 ##

某些情况下，当两个订单匹配时，由于四舍五入的原因，一个订单可能支付得更多，甚至支付了金额但什么也没得到。 这看起来不公平。

该BSIP提出了一种全面的机制，可以在匹配订单时减轻四舍五入的问题，完全避免了无中生有的的问题。

该BSIP还为订单匹配设定了两个原则：

- 永远不会支付太多金额，而且
- 无中生有的问题不应该发生。

## 动机 ##

系统中有一些机制试图避免无中生有的问题，但是，并非所有场景都得到很好的处理，请参阅[bitshares-core issue #184](https://github.com/bitshares/bitshares-core/issues/184)中的例子。

除此之外，四舍五入的问题经常发生并且给市场参与者带来了很多困惑，请参阅[bitshares-core issue #342](https://github.com/bitshares/bitshares-core/issues/342)中的例子。

## 基本原理 ##

### 数量、价格与四舍五入 ###

系统中的数量是每种资产固定精度的整数。 资产的最小正数称为一个Satoshi。

系统中的价格是有理数，表示为base_amount / quote_amount（此处省略精度）。

要计算多少量的资产B会与某个量的资产A的金额相等，需要计算amount_of_a * a_to_b_price，即amount_of_a * b_amount_in_price / a_amount_in_price。 该公式的准确结果是一个有理数。 要将其转换为最终结果即数量，也就是一个整数，可能需要四舍五入。

### 订单匹配 ###

订单意味着有人愿意给出一定数量的资产X，期望获得一定数量的资产Y.两个资产之间的比率是订单的价格。价格可以表示为x_amount / y_amount或y_amount / x_amount，当我们知道价格中哪个数量属于哪个资产时，这两个表达式是等价的。资产X的数量是已知和固定的。

在市场中，例如，在X：Y市场，有些人为买入Y而卖出X，有些人为买入X而卖出Y（或者说用资产Y来购买X）。订单按类型（买入或卖出）分类，然后按价格排序。对于每种类型，提供最佳价格的订单位于顶部。因此，在每个市场中可能存在最顶部的买单和最顶部的卖单，将其称为最高出价和最低要价，因此存在最高出价（就资产X数量/资产Y数量而言），以及最低要价价格（以资产X数量/资产Y数量计算）。

当最高出价高于或等于最低要价时，两个最顶部的订单就可以相互匹配。

### 匹配价格 ###

在连续交易市场中，订单被一个一个下单的，当比较每两个订单时，一个订单比另一个订单下单更早这是确定的。

在比特股中，它并不意味着包含第一个订单的交易在事务是在包含第二个订单的交易之前签名的，而是意味着在产生包含第二个订单的块的见证节点中，第一个订单的处理要早于第二个订单的处理。

当两个订单相匹配时，先前放置的是卖方，另一个是买方。 比如说，卖方提供报价，买方接受报价。 因此，在计算谁将获得多少时，我们使用卖方订单的价格，即卖方的价格作为匹配价格。

### 妥协的必要性 ###

当匹配两个订单时，由于四舍五入的原因，通常我们无法完全满足双方的要求。

以下是[bitshares-core issue #132](https://github.com/bitshares/bitshares-core/issues/132)的第4条评论中提到的示例：

Alice的订单：以$ 3/8出售CORE，余额为1000000 CORE Bob的订单：以$ 19/50购买CORE，余额$ 10

两种资产的精确度均为1，即订单余额分别为1000000 CORE-satoshis和10 USD-satoshis。

Alice的售价为$3/8 CORE= $0.375/CORE，而Bob则以$19/50购买CORE = $0.38，因此基于价格，Alice和Bob应该匹配。

Bob的$10/$0.38~26.3美元。所以26.3是他愿意接受的CORE的最小值（假设“价格”的含义是“一方在交易中接受的汇率的最小值”）。结合satoshis不可分割的设计限制，实际上这意味着Bob只需要10美元即可接受27个或更多CORE。

但$10/27的价格小于$0.370和$0.371，这比Alice的0.375美元的售价要小。所以任何一方都不能满足这个要求。

我们需要达成妥协。

### 可能的方案 ###

在[bitshares-core issue #132](https://github.com/bitshares/bitshares-core/issues/132)的第5条评论中列出了一些可能的解决方案：

- （a）以低于其订单中指定价格的汇率满足某人。缺点：这违反了上述价格定义;即，如果用户输入了一个价格，希望系统在任何情况下都不会低于这个价格出售，系统将不会总是以满足用户意图的方式进行操作。
- （b）两笔订单都要入账。缺点:这会使匹配算法变得更加复杂，因为现在Alice可能能够匹配Bob的订单后面的订单。简单的实现可能具有无限的匹配复杂性;可能有更聪明的实现，但需要大量的设计和测试工作。
- （c）取消订单。由于不能取消诸如追加保证金的订单，使这一点变得复杂。缺点：当发生追加保证金时，仅仅因为追加保证金正好会导致四舍五入的问题，就删除一个愿意填补保证金的大订单似乎是不合常理的的。此外，此机制取消的订单无法退款。否则，想要在所有节点上消耗大量内存的攻击者可能会创建大量订单，然后触发此情况取消所有订单，收回他们在延期取消费用上的投入，而无需按预期支付取消操作的每次订单费用。
- （d）要求所有订单使用共同资产。 Altcoin交易所和许多现实世界的市场（如股票市场）通过指定一个资产作为共同资产来解决这个问题，指定一个“tick”，这是价格精度的最小单位，并要求所有价格都统一。缺点：使市场UI的实现变得复杂，可能需要重新设计一部分市场GUI，降低用户灵活性，新的资产字段需要指定精度，如果n资产存在，那么就可能存在O（n ^ 2）的市场，我们需要弄清楚如何确定所有这些的精度要求。

### 所选方案 ###

目前代码实际上首先实现了方案（a）：当匹配两个订单时，如果存在四舍五入的问题，数量较小的订单将以不太优惠的价格来完成。这是最不坏的折中方案，因为它在解决方案中具有最高效率（最高交易量且不难实现）。

该算法可以描述如下（示例代码在[这里](https://github.com/bitshares/bitshares-core/blob/2.0.171105a/libraries/chain/db_market.cpp#L311-L324)）：

假设卖方订单是出售数量X的资产A，价格为maker_price = maker_b_amount / maker_a_amount;假设买方以数量Y的资产B购买资产A，价格为taker_price = taker_b_amount / taker_a_amount。无论如何，由于这两个订单将以卖方价格匹配，只要它高于或等于卖方价格，买方价格在这里并不重要。注意:目前所有的限价单都是执行限价单，所以在这个例子中，买方的订单只能指定资产B的数量而不能指定资产A的数量。

现在将X * maker_price与Y进行比较。为了精确（避免四舍五入），将X'= X * maker_b_amount与Y'= Y * maker_a_amount进行比较。

- 最好的情况是X'== Y'，这意味着两个订单都可以完全满足maker_price。
- 如果X'<Y'，则表示卖方订单可以完全成交，但卖方订单不能，也就是卖方订单更小。在这种情况下，卖方向买方支付资产A的数量X，买方向卖方支付资产B的数量Y“= round_down（X'/ maker_a_amount）。注意：由于向下取整，Y”可能小于有理数X * maker_price，这意味着Y“/ X可能低于maker_price，表示卖方订单可能以不太优惠的价格成交。
- 如果X'> Y'，则表示买方的订单可以完全成交，但卖方订单不能，也就是买方订单较小。在这种情况下，资产B的买方支付金额Y到卖方，卖方向买方支付资产A的金额X" = round_down(Y' / maker_b_amount)。注意：由于向下取整，X”可能小于有理数Y / taker_price，这意味着Y / X“可能高于taker_price，也就是说，接受者订单可能以不太优惠的价格成交。

### 所选方案的问题 ###

#### 无中生有的问题 ####

当以不太优惠的价格成交小订单时，接收的数量通常向下取整到零，从而导致无中生有的问题。当前的代码试图通过在没有接收到任何资产时取消较小的订单来解决问题，但仅在少数情况下应用此规则（被处理方不会为此付出任何费用）：

- 当匹配两个限价单时，处理卖方
- 当限价单与要价单匹配时，处理要价单
- 当结算单与要价单匹配时，处理要价单
- 全局结算时，处理要价单

其他需要处理的情景（这些待处理方可能在当前系统中无需支付任何费用）：

- 当匹配两个限价单时，处理买方
- 当限价单与要价单匹配时，处理限价单
- 当强制结算单与要价单匹配时，处理结算单
- 全局结算时，处理结算资金
- 当某资产全局结算后进行强制结算时，从全局结算资金支付强制结算单，处理结算单

#### 更广泛的四舍五入的问题 ####

无中生有只是四舍五入问题的一个子集，它是最极端的问题。还有更多的情况是，匹配的一方会支付更多的钱，尽管他们并没有为此付出任何代价。在[bitshares-core issue＃342](https://github.com/bitshares/bitshares-core/issues/342)中讨论了一些场景。

以类似于[bitshare-core issue＃132](https://github.com/bitshares/bitshares-core/issues/132)的第4条评论中描述的场景为例：

- Alice的订单：以$3/80的价格出售CORE = $0.0375，余额为50 CORE
- Bob的订单：以$19/500购买CORE = $0.038，余额为$100

当前系统将按如下方式处理它们：

- 如果Alice的订单是卖方，使用$ 3/80作为匹配价格;因为Alice的订单较小，有利于Bob的订单，所以Alice将支付整个50 CORE并获得round_down（50 CORE * $ 3/80 CORE）= round_down（$ 1.6）= $ 1，有效价格为$ 1/50 = $ 0.02;
- 如果Bob的订单是卖方，使用$ 19/500作为匹配价格;由于Alice的订单较小，有利于Bob的订单，因此Alice将支付整个50 CORE并获得round_down（50 CORE * $ 19/500 CORE = round_down（$ 1.9）= $ 1，有效价格仍为$ 1/50 = $ 0.02。

这两个结果都远远不是Alice的理想价格0.0375美元。实际上，根据Bob的预期价格，支付round_up（$ 1 * 500 CORE / $ 19）= 27 CORE就足够了，那么有效价格将是$ 1/27 = $ 0.037，这仍然低于Alice的期望价格$ 0.0375，但比$ 0.02更接近。


### 该BSIP提出的改进方案 ###

本BSIP提出的详细规则强调了新规则：

- 匹配有利于买方，或者说，以卖方价格匹配;
- 根据以下规则对接收数量进行四舍五入。

	- 匹配两个限价单时，对较小订单的接收数量向下取整，

		- 如果较小的订单什么都没有，就取消订单;
		- 否则，计算较小订单支付的数量round_up（receiving_amount * match_price）。
		- 在两个订单成交后，对于每个剩余的订单（剩余数量为正数），检查剩余的数量，如果数量太小，则订单在下次匹配时不会收到任何东西，取消订单。

	- 将限价订与要价单匹配时（注意：此规则在[BSIP 38](https://github.com/bitshares/bsips/blob/master/bsip-0038.md)中已更改），

		- 如果要价单收到全部债务数量，这意味着它是较小的订单，并且在匹配结束后空头头寸将被平仓，将其支付的数量向上取整;否则，对支付的数量向下取整。
		- 在后一种情况下，
			- 如果限价单没有收到任何东西，取消它（它更小，所以可以安全取消取消安全）;
			- 否则，计算限价单支付的数量为round_up（receiving_amount * match_price）。两个订单成交后，如果限价单仍然存在，则剩余数量可能太小，因此取消它。



	- 将结算单与要价单匹配时，

		- 如果要价单收到全部债务数量，这意味着它是较小的订单，并且在匹配结束后空头头寸将被平仓，将其支付的数量向上取整;否则，对支付的数量向下取整。
		- 在后一种情况下，
			- 如果结算单没有收到任何东西，
				- 如果结算单完全成交，取消它;
				- 否则，这意味着两个订单都不会被完全成交，这可能是由于达到maximum_force_settlement_volume，在这种情况下，不成交这两个订单中的任何一个，并在此块停止匹配该资产;
			- 否则（如果结算单没有收到任何东西），计算结算单将支付的数量为round_up（receiving_amount * match_price）。在成交两个订单后，如果结算单仍然存在，则再次将结算单与要价单进行匹配。在新的匹配中，由于结算单太小，它将被取消，或者由于达到maximum_force_settlement_volume而停止匹配。

		- 也就是说，只有在完全成交时才对要价单支付的抵押金额进行四舍五入，所以如果在匹配后要价单仍然存在，其抵押比率将不会比之前更低，这意味着我们不会引发黑天鹅事件，也不需要检查是否会引发黑天鹅事件。

	- 当全局结算时，有利于全局结算基金，向上取整抵押金额。

	- 从全局结算基金支付结算单时，对于预结算市场，不存在四舍五入的问题，也不需要处理无中生有的的问题;对于其他资产，请遵守以下规则：
		
		- 如果结算数量等于该资产的总供应量，则向结算单支付剩余的全部结算资金;
		- 否则，由于其数量较大，有利于全局结算基金，向下取整减少抵押金额。如果结算单没有收到任何东西，则引发异常（也就是让操作失败）。否则，计算结算单将支付的数量为round_up（receiving_amount * match_price）;在订单成交后，如果订单中还有一些剩余的数量，请将其退还给所有者。

### 改进方案的示例 ###

#### 示例1 ####

以[bitshares-core issue＃132](https://github.com/bitshares/bitshares-core/issues/132)的第4条评论中提到的例子为例：

- Alice的订单：以$3/8= $0.375出售CORE，余额为1000000 CORE
- Bob的订单：以$19/50购买CORE = $0.38，余额$10

处理：

- 如果两个订单都是限价单
	- 如果Alice的订单是卖方，请使用$ 3/8作为匹配价格;因为Bob的订单较小，四舍五入有利于Alice的订单，所以Bob将获得round_down（$ 10 * 8 CORE / $ 3）= round_down（26.67 CORE）= 26 CORE，Alice将获得round_up（26 CORE * $ 3/8 CORE） = round_up（$ 9.75）= $ 10，有效价格为$ 10/26 CORE = $ 0.3846。
	- 如果Bob的订单是卖方，请使用$ 19/50作为匹配价格;由于鲍勃的订单较小，四舍五入有利于Alice的订单，因此Bob将获得round_down（$ 10 * 50 CORE / $ 19 = round_down（26.32 CORE）= 26 CORE，Alice将获得round_up（26 CORE * $ 19/50 CORE）= round_up（$ 9.88）= $ 10，有效价格仍为$ 10/26 CORE = $ 0.3846。
- 如果Alice的订单是一个要价单，因为它的订单更大，四舍五入有利于它，我们会获得相同的结果。

#### 示例2 ####

如果我们将示例更改为：

- Alice的订单：以3 CORE / $ 8 = 0.375购买CORE，余额$ 1000000
- Bob的订单：以19 CORE / $ 50 = 0.38卖出CORE，余额为10 CORE

处理：

- 如果两个订单都是限价单，我们会得到与上述类似的结果。
- 如果Bob的订单是一个要价单，它的债务数量应该是一个整数，例如26美元

	- Alice会得到
		- round_up（26 * 3/8）= round_up（9.75）= 10 CORE作为卖方，或
		- round_up（26 * 19/50）= round_up（9.88）= 10 CORE作为买方。

	- Bob将获得26美元的全部债务。

- 如果Bob的订单是一个要价单，但债务金额有点高，例如27美元，那么Alice就会得到

	- round_up（27 * 3/8）= round_up（10.125）= 11 CORE作为卖方，或
	- round_up（27 * 19/50）= round_up（10.26）= 11 CORE作为买方。

但是，由于抵押只有10个CORE，因此这场匹配将失败并引发黑天鹅事件。

#### 示例3 ####

如果我们将示例更改为上面使用的示例：

- Alice的订单：以$3/ 80的价格出售CORE = $0.0375，余额为50 CORE
- Bob的订单：以$19/ 500购买CORE = $0.038，余额$100

假设两个订单都是限价单，它们将按如下方式处理：

- 如果Alice的订单是卖方，使用$ 3/80作为匹配价格; 由于Alice的订单较小，四舍五入有利于Bob的订单，因此Alice将获得round_down（50 CORE * $ 3/80 CORE）= round_down（$ 1.6）= $ 1，Bob将获得round_up（$ 1 * 80 CORE / $ 3）= round_up （26.67 CORE）= 27 CORE，有效价格为$ 1/27 = $ 0.037;
- 如果Bob的订单是卖方，使用$ 19/500作为匹配价格; 由于Alice的订单较小，四舍五入有利于Bob的订单，因此Alice将获得round_down（50 CORE * $ 19/500 CORE = round_down（$ 1.9）= $ 1，Bob将获得round_up（$ 1 * 500 CORE / $ 19）= round_up（ 26.3 CORE）= 27 CORE，有效价格也是$ 1/27 = $ 0.037。


## 详述 ##

### 当匹配两个限价单 ###

#### 处理无中生有的问题 ####

在数据库类的match（const limit_order_object＆，OrderType ...）方法中，在计算了接收者的usd_receives之后，检查它是否为零。 如果结果为true，跳过并查看订单已成交，返回1，因此订单将在稍后取消。

#### 处理四舍五入的问题 ####

在数据库类的match（const limit_order_object＆，OrderType ...）方法中，，对于较小的订单，在计算接收量后，如果不是零，计算支付为round_up(receives* match_price)。

如果较小的订单是买方，则在成交后，即使订单中仍有一些剩余数量，请将其视为完全成交并将返回值的最低位设置为1。

如果较小的订单是卖方，因为它在成交时将被剔除，无需更改逻辑。

### 匹配一个限价单与一个要价单 ###

在数据库类的check_call_orders（...）方法中，如果要价单较小，则向上取整order_receives，否则向下取整order_receives。

在后一种情况下，

- 如果order_receives为零，则跳过成交并取消限价单。
- 否则，将order_pays计算为round_up（order_receives * match_price），然后完全成交限价单，或者由于部分成交后剩余量太小而被剔除。

### 匹配一个结算单与一个要价单 ###

在数据库类的match（const call_order_object＆，...）方法中，如果要价单较小，则向上取整call_pays，否则向下取整call_pays。

在后一种情况下，检查call_pays是否为零。

- 如果为0，
	- 如果call_receives等于settle.balance，则调用cancel_order（...）并将参数设置为settle，然后返回零数量的抵押资产对象;
	- 否则，直接返回零数量的抵押资产对象。
- 否则，将call_receives计算为round_up（call_pays * match_price），然后正常成交两个订单。如果结算单在匹配后仍然存在，则稍后将再次处理，但条件不同。

返回后，需要检查调用match（...）函数的返回资产量，具体来说，是数据库类的clear_expired_orders（）函数。如果返回的数量为0，则跳出while循环。如果结算单仍然存在并且返回的数量为0，则标记该资产的处理已完成。另外，在外循环中，需要检查标签，如果发现它已完成，则处理下一个资产。

### 全局结算 ###

在数据库类的global_settle_asset（...）方法中，向上取整支付量。

### 从全局结算资金中支付结算单 ###

在asset_settle_evaluator类的do_apply（...）函数中，计算出settled_amount并根据“总供给”规则对其进行调整后，检查它是否为0。

如果为0，并且资产不是预测市场，则抛出一个fc :: exception。

如果不为0，并且资产不是预测市场，并且op.amount.amount不等于mia_dyn.current_supply，则计算支付为round_up（settle_amount * bitasset.settlement_price），然后，仅从总供应中扣除支付量， 并退还op.amount.amount - 支付量给用户。

## 讨论 ##

有一个观点认为，在匹配要价单时，我们应该总是支持要价。 如果结算结果是0抵押，这是可以接受的，因为在请求结算时结算价格是未知的，因此不会违反任何保证（在四舍五入错误的范围内）。 只要存在未偿债务，抵押应该大于0。 一种相反的观点支持将向上取整到1Satoshi，因为向下取整可能会打破“每一个智能货币都有某种东西支持”的承诺。

有一个论点说，打破min_to_receive限制是不行的，因为这就是为什么它被称为“限价单”。 一个相反的观点说，略微突破限度是最不坏的妥协。

## 股东总结 ##

[如果有的话，再补充]

## 版权 ##

本文档放置于公共域名下。

## 查看 ##

- [https://github.com/bitshares/bitshares-core/issues/132](https://github.com/bitshares/bitshares-core/issues/132)
- [https://github.com/bitshares/bitshares-core/issues/184](https://github.com/bitshares/bitshares-core/issues/184)
- [https://github.com/bitshares/bitshares-core/issues/342](https://github.com/bitshares/bitshares-core/issues/342)