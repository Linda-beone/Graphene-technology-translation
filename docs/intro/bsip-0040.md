
原文链接：https://github.com/bitshares/bsips/blob/master/bsip-0040.md
译者：bt666

    BSIP：0040
    标题：自定义活动权限
    作者：
       StefanSchießl<https://github.com/sschiessl-bcp>
    贡献者和审核者：
       Alex Megalokonomos <https://github.com/clockworkgr>
       Fabian Schuh <https://github.com/xeroc>
       升技<https://github.com/abitmore>
       Peter Conrad<https://github.com/pmconrad>
    状态：草稿
    类型：协议
    创建时间：2018-07-25
    讨论：https：//github.com/bitshares/bitshares-core/issues/1061
    工人：<工人提案的ID>



## 摘要 ##

加强用户安全是提升比特股的主要因素之一。鉴于最近的黑客攻击和网络钓鱼风险，加强安全变得更加重要。对帐户权限更精细的控制才能满足对更复杂的帐户安全性的需求。我们建议向帐户添加一个额外的许可，称为自定义活动(许可)。许可包含一个操作ID到权限的映射列表，每个映射都授予对各自操作的访问权，就好像它是帐户的活动许可一样。此外，可以限制上述操作的参数。

对于非技术读者，可以跳过**详述**这一节。

## 动机 ##

任何针对比特股区块链上运行的网页钱包所发起的黑客或网络钓鱼攻击，它们的成功都是一种糟糕的宣传。用户需要接受账户安全方面的培训，这个BSIP旨在确保所有技术上的可能性，同时可以灵活地使用众多用例。

有了这个BSIP，任何用户都可以创建具有特定用途的额外密钥(其他一切都是禁止的)。我们列出了以下几种可能性:

- 见证密钥:只允许更新签名密钥和发布喂价
- 交易密钥:只允许限价单(只适用于预期市场)，更新保证金头寸和转账(只适用于特定账户)
- 提案更新密钥:批准提案(想到2FA)
- 水龙头密钥:只允许创建帐户
- 提现密钥:允许其他账户向自己转账
- 冷藏密钥:只允许将资金转移到热钱包
 
上面列出的的命名密钥对于后端来说是已知的，因为后端应该有一个抽象的实现。UI可以提供一个“创建交易密钥”按钮，用来合理地配置相应的自定义活动许可项。

注意:用户仍然可以像以前一样使用活动权限，不会改变现有的行为。命名密钥只提供了额外的可能性。例如:用户可以使用这样一个命名密钥的私钥登录UI。然后他只具有该命名密钥所授予的操作权限。他仍然可以使用现有的密码登录从而获得完全访问权限(类似地，可以创建只包含指定密钥的本地钱包)。

这个BSIP将被分成几个部分，分别进行投票(参见**重要阶段**部分)。上面所有的密钥在阶段1中都是可能的。阶段2允许有状态限制(例如，允许每月的市场订单达到一定数量)，阶段3对如何组合限制提供了更好的控制，而阶段4允许设置每个权限允许执行的数量(引入了额外的链上依赖)。如果阶段1证明是成功的话，那么将对阶段2、3和4进行投票。

## 基本原理 ##

自定义活动许可是**自定义活动权限**的列表。**自定义活动权限**包含一个**operation_id**、一个**权限**(与活动许可类似)和可以用来限制参数的**限制**。此外，这样的**自定义活动权限**仅在指定的时间段内有效(**valid_from**和**valid_to**)。在处理输入签名的交易时，后端检查每个操作是否有其所需帐户的**自定义活动权限**。如果交易的所有从属操作都至少有一个确定匹配的**自****定义活动权限**(参见“匹配”定义的**详情**)，则检查交易的每个必需的帐户，如果是这样的话，就跟存在相应帐户的活动权限一样(排除递归权限，请参阅示例)。

## 详述 ##

本节中的所有描述都是伪代码/符号地址级别，对于如何最佳的实现或者序列化没有做出建议。它们旨在让大家更好的理解。如果循环过程或评估顺序中有不适合具体实现的内容，只要能够实现相同的功能，就可以相应地进行更改。

注意:阶段4的影响将在它自己的小节中解释，以免妨碍阅读

**自定义活动许可和自定义活动权限**

**自定义活动许可**包含**自定义活动权限**的列表，看起来如下(使用类JSON/伪代码的格式说明):

    custom_active_permission = {
    account_id,// 分配有这个权限的帐户
    authorities = list of custom_active_authority objects
    }
    custom_active_authority = {
    enabled,// 权限状态，true或false。创建时为true
    valid_from, // 活动时的时间戳
    valid_to,   // 无效时的时间戳
    operation_id,   // 目标操作的操作ID
    authority,  // 与现有权限相同（使用带权重帐户或密钥多签名）
    restrictions// 见下文
    }

注意:这假设**custom_active_permission**存储在一个单独的索引中。具体实现细节留给实现者，只要每个**custom_active_permission**可以被分配给一个帐户。

自定义活动权限与传入的已签名交易的操作相匹配。用词匹配是指:

- **operation_id**等于传入操作的id
- **account_id**是操作所需的帐户
- **custom_active_authority**的**权限**由交易的签名给出
- 时间戳**now**在**valid_to**和**valid_from**中
- 所有**限制**都是肯定的

**限制**

**restrictions**字段是一个限制列表，由几个用于断言映射的参数组成。类似于字典类型的对象

    restriction = {
       function, // 参数定义
       argument, // 动态值的指针 (操作参数, 或者嵌套时的属性)
       data, // 特定方法的数据
    }

称为限制，它可以断言自己肯定的(通过的)或否定的(违反的)。所有的限制都默认使用**AND**逻辑来评估，以确定整个列表是否已经肯定地断言。

可能的限制包括:

<table style="text-align:center;"><tbody>
    <tr>
        <th > <font face="bold">function</font> </th> <th > <font face="bold">data</font> </th> <th > <font face="bold">state</font>  </th>
    </tr>
     <tr>
        <td > any </td> <td > [list, of, allowed, values] </td> <td > stateless </td>
    </tr>
 <tr>
        <td > none </td> <td > [none, of, these, values] </td> <td > stateless </td>
    </tr>
 <tr>
        <td > lt, le, gt, ge, eq, neq </td> <td > comparative </td> <td > stateless </td>
    </tr>
 <tr>
        <td > contains_all, contains_none	 </td> <td > [list, of, values] </td> <td > stateless </td>
    </tr>
 <tr>
        <td > limit	 </td> <td > [max_cumsum, interval_in_sec] </td> <td > [current_cumsum, interval_began] </td>
    </tr>
 <tr>
        <td > limit_monthly </td> <td > [max_cumsum, interval_in_months] </td> <td > [current_cumsum, interval_began] </td>
    </tr>
 <tr>
        <td > attribute_assert </td> <td > list of restrictions </td> <td > stateless </td>
    </tr>
 <tr>
        <td > logical_or </td> <td > list of restrictions lists </td> <td > stateless </td>
    </tr>
</table>

下列情况必须受到限制:

- 安装**custom_active_authority**时，将检查基本参数类型(没有嵌套)，如果不匹配，则不允许安装
- 如果没有给定的值(例如，一个可选的参数，或者未给出嵌套的值)，就会传递限制(即使底层操作理解缺少密钥是链上删除该密钥的一个指示，请参阅bitshares/bitshares-core#838)
- 如果参数的预期类型与给定类型不匹配(没有隐式类型转换)，那么就违反了限制(嵌套**attribute_assert**的需要)
- 如果限制的方法断言是否定的，那么就违反了限制

注意:

- 如果需要，可以添加一个字段来存储假定的参数类型
- 可以重新定义此限制列表，以提高清晰度、性能或降低实现的复杂性，同时保持预期的功能

在下面我们列出了可能的**限制**。在下文中提到**参数值**是指由限制的**参数**指定的操作的参数值。

**any**

无状态断言，所有参数类型。**参数值**必须等于数据列表中的一个值。

**注意**

- 如果对性能或复杂性有利，则可以使用额外的操作**equal**，只用来与1进行比较。

**none**

无状态断言，所有参数类型。**参数值**必须不等于列表中的任何值。

**注意**

- 如果对性能或复杂性有利，则可以使用额外的操作**not_equal**，只用来与1进行比较。

**lt, le, gt, ge, eq, neq**

无状态断言。允许显式类型转换:

- **int**类型:按原样使用
- **string**类型:使用字符串**长度**作为**参数值**
- **object**类型:使用对象的**大小**作为**参数值**
- **list**类型:使用列表的**长度**作为**参数值**

不同的断言解读为:

- **lt**：**参数值**必须小于**比较值**
- **le**: **参数值**必须小于或等于**比较值**
- **gt**：**参数值**必须大于**比较值**
- **ge**：**参数值**必须大于或等于**比较值**
- **eq**: **参数值**必须等于**比较值**
- **neq**：**参数值**必须不能等于**比较值**

**注意**

- **eq**和**neq**是隐式数字比较操作，不要误解成是左右两边绝对相等的操作，就像lt, le, gt, ge(例如，比较**1 > 列表**对象，是没有意义的)
- 如果对性能或复杂性有利，则可以删除隐式类型转换，并引入不具有隐式类型转换的不同操作符

**contains_all,contains_none**

无状态断言，用于列表类型参数。

- **contains_all**:**参数值**必须包含**数据**指定的所有项，但可以包含更多项
- **contains_none**:**参数值**不能包含任何由**数据**指定的项，但可以包含其他项

**limit**

有状态断言，只有int类型的参数。创建权限时，**interval_started**被设置为**valid_from**，表示它的自定义活动权限开始时间，**max_cumsum**设置为**0**。传入操作首先尝试匹配所有无状态的断言，如果所有断言都通过了，则继续匹配有状态的断言。如果**now > interval_started + interval_in_sec**，那么设置**max_cumsum = 0**，并设置**interval_started = now**。断言的通过需要现在的**current_cumsum +传入值<= max_cumsum**。如果这个**custom_active_authority**的所有断言都通过，那么更新**current_cumsum = current_cumsum +传入的值**。

**limit_monthly**

有状态断言，只有**int**类型的参数。与limit类似，但是**interval_started**最初设置为**month(valid_from)**，并在更新时设置为**month(now)**，另外时间断言是**month(now) >= interval_started + interval_in_months**(当年份发生变化时，包含用于月溢出的逻辑)。**month(now)**的调用假定使用祖鲁时间来计算月份。

**attribute_assert**

无状态断言，仅用于字典类型对象。数据列表包含所有必须通过的限制，子限制的**参数**引用嵌套在父字典类型对象的属性中。允许**attribute_assert**的嵌套。

**logical_or**

无状态断言，仅用于字典类型对象。数据是一个限制列表的列表。即，**数据=[[限制1，限制2]，[限制3，限制4]，…]**。如果数据中的一个限制子列表作为一个整体传递，这个限制就会断言通过。在上面的小例子中，这意味着如果**限制1**和**限制2**断言通过，那么整个**logical_or**限制也被认为是断言通过的。

**处理传入交易的概述**

当已签名的交易到达后端，在后端评估出是否所有必要的权限都具有签名之前，执行以下操作:

- 迭代**所需的帐户**
	- 在需要此帐户的活动权限的交易中迭代所有**操作**(不包括提案的子操作)
		- 迭代该帐户的**custom_active_authority**，如果匹配，记住它并继续下一个**操作**
	- 如果循环中的每个操作匹配到了**自定义的活动权限**，就跟存在相应帐户的**活动权限**一样。

注意:

- **custom_active_authority**只能授予相应操作所需帐户的**活动权限**，仅此而已
- 所需帐户的实际活动权限仍然可以像以前一样给出，不改变现有行为
- 这是为了给出说明，而不是真正实现时的操作指南

**后端修改**

- 添加一个新索引或扩展帐户对象来存储分配给帐户的自定义活动权限，并包含自定义活动权限列表。一个操作可以使用多个自定义活动权限项
- 提供操作:**install_custom_active_authority、update_custom_active_authority、delete_custom_active_authority**，以允许更改自定义活动权限(3个操作，允许自定义交易费用，并避免在每次更新时发送所有权限的完整列表)
- 如果帐户的活动权限被更新，所有自定义活动权限都被禁用，必须手动开启/重新启用。用户可以
	- 通过在**account_update_operation**扩展中的**custom_active_authority**列表中指定权限从而保证它们可用
	- 使用**update_custom_active_authority**再次启用它们
- 特定于操作的权限(如果存在)必须在传入的交易中进行评估
- 如果**custom_active_authority**过期时间超过一个月，则将其删除不与维护
- 可能需要额外的委员会参数来限制该特性的使用范围

注意:实现不能区别对待自定义活动权限所应用的操作，所有操作都以相同的方式处理

**阶段4:执行次数**

如果实现了阶段4，**自定义活动权限**将接收到额外的**remaining_executions**字段，以指定允许的执行次数。用户可以选择限制有效的时间段和/或执行的次数，但是如果指定了时间段，执行的次数只能是无限的(没有设置)。然后，如果时间段有效或未设置，则**自定义活动权限**匹配，并且**remaining_executions**的值要么未设置，要么大于0。当**自定义活动权限**成功授予相应操作的活动权限，并执行整个交易时，**remaining_executions**将减少1。如果它变为零，**自定义活动权限**将被禁用。如果**自定义活动权限**在一个月内没有被用户再次启用，则会被删除。

**经济学**

添加自定义活动权限意味着后端工作增加，而有状态的权限还需要更多的存储。因而提出了交易费用:

- **install_custom_active_authority**:普通帐户只能创建自定义的活动权限，期限最长为1年，终身会员的期限不受限。我想到了两个选择:
	- 独立于权限内容的固定高额费用
	- 与自定义活动权限的持续时间和复杂性有关。交易费用即**fee = flat_fee + basic_fee * duration**，其中**basic_fee**是根据复杂度(例如权限大小、限制数量等)来计算的。**duration**时间指的是剩余的时间，而不是设置的持续时间(即**date_to - max(now, date_from)**)
- **update_custom_active_authority**:基本费用类似于**account_update**加上持续时间的增加带来的动态费用，如果减少持续时间，不会有返现(增加/减少分别使用间隔的结束时间来计算）
- **delete_custom_active_authority**:与**limit_order_cancel**类似

这种逻辑强制用户考虑所需的持续时间，让他们设置短的而不是过长的持续时间。如果自定义活动过期了，或被认为时间过短，那么可以很容易地对其进行扩展。过期后，自定义活动将被禁用，并且仍然可以设置新的时间来再次启用，需要支付新时间段的费用。

注意:

- 对于阶段4，如果没有设置时间段，安装费用将取决于执行的次数。

## 讨论 ##

在[issue](https://github.com/bitshares/bitshares-core/issues/1061)和[pull request](https://github.com/bitshares/bsips/pull/86)中查看。

## 示例 ##

这些示例仅用于说明，没有实际序列化的规范。

**示例:嵌套的参数，比如选项**

假设**asset_update_operation**。其**选项**的所有属性必须在更新调用时填写。这个断言不能用于实现“可能只更改**选项**的xzy属性”。这将要求逻辑知道哪些参数在链上反映，并且知道如何查询包含**选项**的每个操作。如果要使用此断言限制**选项**，那么所有不应该更改的值都需要通过为这些属性定义一个any断言来确定，对于可以更改的属性，可以使用如lt断言来定义。

**例如:简单的转账**

假设帐户A和帐户B以及一些不相关的密钥K，应该设置自定义活动权限，以便从A发送资金的转账交易可以使用密钥K进行签名，只要接收方是B。更具体，权限看起来就像

    custom active authority = {
    valid_from: 7.7.2018 00:00
    valid_to: 8.7.2018 00:00
    operation_id: transfer,
    authority: {
       threshold: 1
       key_auth: [key K, 1]
       account_auth: []
    },
    restrictions: [
    {
    function: any,
    argument: to,
    data: [account B]
    } // 使用“to”限制参数
    ]
    }

例子输出结果:

- 将X资产与Y金额从A账户转移到B账户，用K密钥签名:接受
- 将X资产与Y金额从B账户转移到A账户，用K密钥签名:拒绝
- 将X资产与Y金额从A账户转移到C账户，用K密钥签名:拒绝
- 将资产X与Y金额从A账户转移到B账户，用B的活动权限签名:拒绝
- 将资产X与Y金额从A账户转移到B账户，用A的活动权限签名:接受
- 创建一个提案，其中包括操作 '将X资产与Y金额从A账户转移到B账户，用K密钥签名:接受'。任何人都可以创建一个提案。

注意:

- 这包括在阶段1中
- 正常的许可逻辑不会改变。账户A仍然可以使用其活动权限签署从账户A到账户B的转账

**涉及多签名**

帐户A具有帐户B和c的多签名活动权限。帐户A拥有自定义活动权限，授予密钥K转账特权(任何资产到任何帐户)。帐户B有一个自定义活动权限，授予密钥L转账特权(任何资产到任何帐户)。

该交易包含从a到帐户d的转账。此操作所需的活动权限为a。

- B和C签字:接受
- L和C签字:拒绝。B的自定义活动权限不匹配，仅适用于以B为发送方的转账
- 由K签名:接受，基本上绕过了多签名。这是有意的，因为多签名首先需要批准自定义活动权限的安装

**递归的活动权限**

假设Alice有一个自定义的活动权限，其密钥为K，用于向Charlie转账。Bob将Alice作为他的活动权限帐户。假设一个包含两个操作的交易

从Alice转1BTS到Charlie
从Bob转账1000BTS到其他帐户

例:

- 交易用K签名
	- 操作1。需要Alice作为活动权限，并且有一个匹配的自定义活动权限，因此允许执行此操作
	- 操作2。要求Bob作为活动权限。虽然Bob将Alice作为活动权限，但是K不能递归地授予Bob的活动权限
	- 整个交易被拒绝
- 交易用K和A签名
	- 操作1。要求Alice作为活动权限，这是存在的，因此允许执行此操作
	- 操作2。要求Bob作为活动权限，这是通过A间接实现的，因此允许执行此操作(现有逻辑)
	- 整个交易被拒绝，因为存在太多签名(现有逻辑)
- 交易用K和B签名
	- 操作1。需要Alice作为活动权限，并且有一个匹配的自定义活动权限，因此允许执行此操作
	- 操作2。要求Bob作为活动权限，这也是存在的，因此允许执行此操作
	- 交易可以执行

例如:或

假设账户A, B, C，资产X，资产y。自定义活动权限现在应该能够实现从A转出资金的转账交易可以使用B的活跃权限进行签名，如果：

- 它向C账户发送小于10000资产X
- 它向帐户C发送小于等于20000的资产Y

更具体的说，权限看起来会像这样

    custom active authority = {
    valid_from: 7.7.2018 00:00
    valid_to: 8.7.2018 00:00
    operation_id: transfer,
    authority: {
       threshold: 1
       key_auth: []
       account_auth: [account B, 1]
    },
    restrictions: [  
    {
    function: logical_or,
    data: [ either_list, or_list ]
    }  
    ]
    }
    
    either_list =
    [  
    {
    	function: attribute_assert,
    	argument: amount,
    	data: [
    	{
    	   function: lt,
    	   argument: amount,
    	   data: 10000
    	},
    	{  
    	   function: any,
    	   argument: asset_id,
    	   data: [ asset X ]
    	}
    	]
       },
       {  
       function: any,
       argument: to,
       data: [ account C ]
       }
    ]
    	
    or_list =
    [  
    {
    	function: attribute_assert,
    	argument: amount,
    	data: [
    	{
    	   function: le,
    	   argument: amount,
    	   data: 20000
    	},
    	{  
    	   function: any,
    	   argument: asset_id,
    	   data: [ asset Y ]
    	}
    	]
       },
       {  
       function: any,
       argument: to,
       data: [ account C ]
       }
    ]

注意:这包含在阶段3中

**示例:检查自定义活动权限**

假设帐户A、B和c。现在A有两个**自定义活动权限**:

- **自定义活动权限1**:允许账户B将资产X转移到D
- **自定义活动权限2**:允许帐户C将资产X转移到D

传入的交易现在包含**从A到D的转账100资产X,由C的活动权限来签署所有所需的签名**。交易所需的账户(意味着所需的活动权限)是账户A。后端将开始考虑**自定义活动权限1**并通过签名来检查帐户B的活动权限是否都存在。不存在，因此继续检查**自定义活动权限2**的权限是否存在(确实存在)。表现得好像帐户A的活动权限存在于匹配操作中，并继续进行正常的权限检查。由于所需的帐户是帐户A，并且给定的帐户也是通过**自定义活动权限2**的帐户A，因此执行交易。

## 重要阶段 ##

我们建议将实现分为多个重要阶段。每个阶段将分别进行投票:

1. 基本函数的实现，允许自定义活动许可和权限，包括**any、none和lt、le、gt、ge、eq、neq、contains_all、contains_none和attribute_assert assert**。如果开发人员认为有必要，减少到每个自定义活动权限只允许一个密钥或一个帐户
1. 实现有状态的断言**limit**和**limit_monthly**
1. 实现**logical_or**
1. 实现**remaining_executions**

## 摘要对股东 ##

在安全性方面的不良宣传会对BTS的价值产生非常负面的影响。该BSIP允许交易者使用交易密钥，见证人可以使用他们的见证人密钥，水龙头可以使用水龙头密钥。如果由于某种原因，密钥或见证/水龙头服务器受到危害，这样的密钥对帐户持有者几乎没有什么危害，从而将风险降至最低。

这个BSIP提供了很多用例，如动机一节所示。目的是不更改权限系统的任何现有逻辑，从而减少了故障的风险。

## 版权 ##

本文档放置于公共域名下。