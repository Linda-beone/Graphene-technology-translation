  **原文链接**：[https://dev.bitshares.works/en/master/knowledge_base/wiki_legacy/architecture_wiki.html](https://dev.bitshares.works/en/master/knowledge_base/wiki_legacy/architecture_wiki.html)
 
 **译者**：[https://github.com/b-t-s-1](b-t-s-1)
 
 **校对者**： 
  
***

结构
============================


石墨烯旨在允许多个应用程序连接到网络。应用程序由p2p节点组成，该节点接收块并可选地代表应用程序的用户广播新的交易。应用程序包含核心逻辑，核心逻辑由核心链状态和核心索引组成，这是达到核心共识所需的最小数据量，参与p2p网络的所有节点之间关于核心功能的共享全局协议。

核心虚拟资产
-----------------------

虚拟财产包含可以拥有的东西。传统加密货币，例如比特币，具有单一类型的虚拟财产：可转移，可互换的数字代币（例如，所有比特币都相同），并且（出于实际目的）可分割。

石墨烯有两种不同类型的数字属性：基本资产和衍生资产。 （经济学家称之为基础财产，但这个术语已经在加密货币领域用作政府发行货币的反义词，用于将其与加密货币区分开来。）

石墨烯核心的基本资产包括:

- 账户
- 核心资产
- UIA

石墨烯核心的衍生资产包括：

- 比特资产
- 债券
- 选项

（代办事项：其他类型的派生财产，例如托管？）

利用石墨烯区块链达成共识的应用程序可以实现它们自己的基础和/或衍生的虚拟资产。 （待办事项：解释应用程序级虚拟资产如何与核心资产进行交互。）

衍生资产是由核心智能合约创建的，这些合约在石墨烯中是硬编码的。 智能合约可以与现实合约一样多样化，但在石墨烯中，所有核心智能合约都是双边抵押合约。 合同的一方必须发布用于执行结算的抵押品。 发布抵押品的一方称为*long side。*

关于比特资产空头头寸不可转让的理由：关于使空头头寸可转让几乎没有技术障碍。 然而，如果Alice是一个弱抵押的空头寻求退出，并且Bob是一个新的空头寻求进入高杠杆，Alice和Bob都有动力让她的头寸卖给他。 希望迫使Alice覆盖并迫使Bob以最小的初始杠杆做空，以便随着时间的推移重新利用空头。

与BitShares的差异
----------------------------

- 做空机制。 做空有维护保证金要求和用户可设置的止损。 未来要做的：文档阐明这是如何工作的。
- 增量订单匹配。 订单在输入时以递增方式匹配。 待办事项：文档阐明这是如何工作的。
- 传统的价格分割。 如果订单在差价上匹配，他们将盈余分成50-50。 TODO：更准确地记录，包括示例。
Traditional price splitting. If orders match at a spread, they split the surplus 50-50. 未来要做的: 文档会更加准确, 包括示例。
- 填写或终止订单。 待办事项：这些如何运作？
- BitAssets 3.0。 待办事项：将论坛帖子等转换为详细的规范，包括示例。
- TaPoS。 待办事项：解释一下。
- 空头失效时间. 待办事项：解释一下。
- Multisig使用权限系统。

--------------------------


## 授权系统

待办事项：记录这个（有点像“人工multisig”）

## 推荐系统

待办事项: 记录这个

## 提议的tx's

待办事项: 记录这一点，包括非常精确的语义

## 自定义操作

自定义操作是带数据的无操作。

## 自定义对象

自定义对象是具有数据和所有者的对象，所有者可以更新数据。 待办事项：这实际上是一件事吗？

## 对象类型列表

待办事项: 写下清单

## 相对ID

待办事项: 记录相对ID的限制。 它们只能用于某些操作 - 哪些操作？ 待办事项：修复此限制


## 盲命名

- 这是一个有趣特征的“理论上的”想法

这是在Namecoin中实现的功能。这是一个提交/显示程序，以防止名称注册的正面运行。注册新名称时，您可以在一个tx中提交（H（名称+分隔符+slat），recipient_pubkey），然后在24小时内，在另一个tx中显示salt以声明该名称。如果提交了多个相同名称的声明，则优先考虑具有最早提交的声明。注意，收件人的pubkey是在提交中给出的，而不是显露的，所以正在运行你的透露的其他人支付费用，但没有获得名称。

请注意，这可能会导致帐户名被撤销（因为它试图声明之前显示的名称）。那么命名对象（例如，帐户，但是账户对象是石墨烯中的唯一命名对象吗？）仍然存在，但只是变得无名。

## 命名空间

- 这是一个有趣特征的“理论上的”想法

许多用户库已经存在，其中一些可能存在名称冲突。诸如`dan`或`nathan`之类的常见名称可能已经在Github，Linkedin，Twitter，Google，Yahoo等上注册，并且在所有这些服务上可能属于不同的人。如果我们的商业模式是说服在线服务迁移他们的用户群，那么我们应该给他们一种方法来命名这些帐户。例如。 `github/dan`，`github/nathan`等，一般来说，`a/b`的注册必须经过帐号`a`批准。

这应该反映推荐结构。例如，如果`a`是你的推荐者，那么你的名字是'a/b`。新账户总是“a/b”，但可以通过买断升级为“b”。嗯，似乎买断也应该让你有机会改变你的名字（因为根NS可能会有冲突），而且这种改变应该是盲命名。

## 封装交易

- 这是一个有趣特征的“理论上的”想法

在传统交易所，未成交的订单是免费的 - 市场费用仅在成交的订单上收取。我们必须按照未成交订单收取最低金额作为反垃圾邮件措施。但是，我们可以想象一个交易务提供商Xavier在外部服务器上托管订单 。当Alice想要下订单时，她会免费创建订单交易，然后将订单上传到Xavier的服务器; Xavier发布它（Xavier将需要实施替代的反垃圾邮件措施来保护他的服务器免受滥用）。

当Bob想要匹配Alice的订单时，他会提供费用。

这是我的想法，如何实现这一点，而无需大幅度重新计算费用结构。我们创建了一个特殊的“社区”帐户（代办事项：更好的名称），带有一个特殊标志，表示不需要任何权力从中提取资金。 Alice签署她的tx从社区帐户支付费用，现在她的tx无效的唯一原因是因为社区帐户没有资金。现在Bob可以创建一个封装的交易，其中包含他的匹配订单，社区帐户的资金以及Alice的tx。封装的tx由Bob签名。至关重要的是，这样做意味着没有人可以在Bob的操作资金社区账户和Alice的支付交易之间插入从社区账户中获取资金的tx。

我们可以用提议的tx做到这一点吗？我们必须非常仔细地考虑所提出的tx的确切语义。

## 帐户移植网关

- 这是一个有趣特征的“理论上的”想法

这也可以用于第三方“帐户移植网关”。例如。假设我们有“电子邮件”帐户，并希望设置一种方式，任何拥有电子邮件地址的人都可以使用BitShares形式声明电子邮件地址。例如，`email/user_at_example_dot_com`将被提供给证明他们控制`user@example.com`的人。 `email` BTS帐户的持有者，而不是核心见证人/验证，负责检查此证明（这可能需要任何无法以非去中心化方式验证的非区块链操作，如发送确认电子邮件）。验证包括签名检查（`“用户电子邮件确认pubkey p owns email / user_at_example_dot_com”`）与`email`帐户的政策（“我们需要在发出姓名之前成功回复注册邮件”）以及对`email`帐户的信任相结合（通过向账户`email/user_at_example_dot_com`汇款，用户信任'email'账户，诚实地将`user_at_example_dot_com`与正确的人联系起来）。

此方法也可以应用于任何具有登录API（Github/Twitter/LinkedIn /等）的用户群的网站，或者甚至仅仅是成员发布内容的能力（例如，在论坛简介中） - 如果你给出用户挑战并且他们成功地将其发布在他们的个人资料或其他出版区域中，他们已经成功确认了对该帐户的访问权限。

对于封装的交易，帐户移植网关可以创建免费tx为用户分配名称，然后用户添加费用以实际注册帐户。这允许帐户移植网关避免必须解决确定哪些注册将导致有利可图的CLV的经济问题，并且仅关注在第三方系统中的诸如电子邮件，DNS，谷歌账号等验证现有名称的所有者的技术问题，同时仍然要求推荐人费用。不可否认，没有“免费午餐”，因为用户需要提供自己的资金，因此用户体验会更加艰难。

## 帐户撤销

- 这是一个有趣特征的“理论上的”想法

需要一个“我丢失了我的电子邮件地址和私钥”按钮，允许电子邮件撤销名称`email/user_at_example_dot_com`。但是，底层帐户应该仍然存在，它只需要与名称取消链接（这样，如果用户以后找到他们的私钥，他们仍然可以访问资金）。该名称应该无法重新分配，直到足够长的延迟，至少允许在撤销区块之前与TaPoS进行交易变得无效（否则如果Alice发送给`user_at_example_dot_com`并且Eve控制电子邮件和单个见证人，Eve可以让她见证人审查包含在区块中Alice的tx，而不是包括tx为自己分配`email/user_at_example_dot_com`，并在tx出现在稍后的区块中时获取资金）。

注意，这种攻击在实践中可能更难，因为客户端会在本地查找name-to-account-ID的映射。有一个撤销期是有道理的 - 如果你在过去30天内从某人那里听到他们的地址是`email/user_at_example_dot_com`，那么你知道你要么将资金发送给对的人或者得到一个错误。此外，如果你的某个联系人已被撤销并重新分配，则钱包应发出警告。

它还使帐户历史变得复杂，因为显示的名称将由执行tx时的名称映射确定。

## 声明操作

- 这是一个有趣特征的“理论上的”想法

声明操作是一种使交易无效的操作，除非声明条件成立。到目前为止，我们有：

- TaPoS声明。声明历史记录中存在特定的区块哈希。所有交易都有此声明，它可以防止交易迁移到ID具有不同对象的分支。

这些可能需要包含在内：

- 数据对象声明。我们可能需要检查具有ID，所有者和自定义内容的数据对象。我们可以声明存在具有给定ID和所有者的数据对象，并且内容的某些功能是真的。

数据对象声明函数的示例：声明内容遵循特定字节模式（包括间隙），声明内容是Merkle/Patricia证明x在S中，声明内容的某些hash是给定值。这些可以组合以构建AXCT智能合约，后者也可用于盲命名方案。

- 日期声明。之前无效或之后无效。每个tx在不久的将来都会到期（之后无效），并且在最近通过TaPoS的某个点之前可能无效。然而，扩展这些窗口可能是有用的，例如，在未来的某个时间之前创建一个无效的交易（这是比特币中的'nLockTime`）。或者在遥远的未来一段时间后创建一个无效的交易。应提供比默认TaPoS到期更灵活的日期声明的机制。可以要求对该机制使用拟议的交易。

- 权限声明。权限声明是一种操作，它将给定的权限添加到使交易有效所需的权限列表中。权限声明有助于使平台操作和应用程序进行原子操作。例如。 Alice和Bob希望创建一个交易来交换她的AppCoin以获取Bob的BitUSD。 tx包括由app层解释的自定义操作，将Alice的AppCoins转移到Bob，如果没有Alice的签名，应用程序不会识别该应用;以及将Bob的BitUSD发送给Alice的常规（平台）转移操作。如果没有权限声明，Alice的签名也需要是自定义操作，这也意味着Alice必须首先签名。 （如果Alice使用常规签名，Eve将能够扮演Alice的角色，剥离她自己的签名并应用Bob的签名，使用Bob的BitUSD而不用她的AppCoins补偿他。）权限声明意味着应用签名不必以这种方式封装，并允许以任何顺序签署tx。

